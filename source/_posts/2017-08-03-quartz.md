---
layout: post
title: "Quartz基础知识及源码分享"
date: 2017-08-03 15:28:11 +0800
comments: true
tags:
    - Java
    - quartz
keywords: quartz, 源码, 基础
---
我们的Quartz是依赖MySQL库的集群模式执行。此篇基于Quartz2.2.1源码。

## Quartz状态解析

在以前的AMP以及现在的KAKA中quartz模块（内部监控系统），我们经常会看到状态栏会展示出WAITING， ACQUIRED，BLOCKED，PAUSED等状态，这些状态的含义是什么呢？
* WAITING：等待执行状态，此时还没有任何机器调度到此定时任务。
* ACQUIRED：已被某台机器锁定，即将执行。
* BLOCKED：定时任务执行中，防止其他机器执行。
* PAUSED：暂停状态，定时任务不会被调度。

## 核心表解析

* qrtz_triggers：触发器信息存储表，记录了触发器组，名称，任务组，名称，创建时间，描述，下次执行时间，上次执行时间，触发器状态等信息。
* qrtz_cron_triggers：cron触发器的表达式存储在这里。
* qrtz_fired_triggers：即将执行和正在执行的定时任务存放处，存放执行机器信息，执行时间，状态等。
这个表里面的状态只有两个，ACQUIRED和EXECUTING。ACCQUIRED对应qrtz_triggers表中的ACCQUIRED状态，EXECUTING对应其中的BLOCKED状态。
* qrtz_locks：Quartz锁存放表，1.8.6之前只有一列，即锁名称，2.0之后有两列，增加了SCHED_NAME，对应相对应的业务集群，很好地解决了几十几百台机器争抢同一把锁的死锁问题。
* qrtz_scheduler_state：调度示例（业务机器）状态，存放扫描间隔，上次扫描时间等信息。

## Dubbo调度方式解析

在dubbo中，我们通过dubbo的container机制实现了调度示例的初始化工作，详情参考如下代码：

``` java 
package com.asura.framework.dubbo.container;

import java.text.SimpleDateFormat;
import java.util.Date;

import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SchedulerFactory;
import org.quartz.impl.StdSchedulerFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.alibaba.dubbo.container.Container;
import com.asura.framework.base.exception.BusinessException;

public class SchedulerContainer implements Container {

	private Logger logger = LoggerFactory.getLogger(SfbestSchedulerContainer.class);
	
	/**
	 * Scheduler
	 */
	private Scheduler scheduler;
	
	/**
	 * 启动QuartzScheduler
	 */
	public void start() throws BusinessException {
		try {
			SchedulerFactory sf = new StdSchedulerFactory("quartz.properties");
			scheduler = sf.getScheduler();
			scheduler.start();
			logger.info(new SimpleDateFormat("[yyyy-MM-dd HH:mm:ss]").format(new Date()) + " Quartz started!");
		} catch (SchedulerException e) {
			logger.error("启动Quartz出错:" + e.getMessage(), e.getCause());
			throw new BusinessException(e.getMessage(), e.getCause());
		}
	}
	
	/**
	 * 停止QuartzScheduler
	 */
	public void stop() throws BusinessException {
		if (null != scheduler) {
			try {
				scheduler.shutdown();
			} catch (SchedulerException e) {
				logger.error("停止Quartz出错:" + e.getMessage(), e.getCause());
				throw new BusinessException(e.getMessage(), e.getCause());
			}
		}
	}

}
```

在asura-dubbo项目中，我们为此container指定了一个名称：

scheduler=com.asura.framework.dubbo.container.SchedulerContainer

最终我们只需要在dubbo.properties中将此scheduler配置在container部分即可，同样的实现参考dubbo-cat。

## Quartz核心业务逻辑解析
1. 启动Quartz中的调度器，代码参考上方asura的启动方式。
2. 调度器启动一个线程（QuartzScheduler.java）不断地去尝试获取即将执行的定时任务。
3. 以锁的方式获取到本实例需要执行的一批定时任务（由当前空闲线程决定获取的多少），并将trigger状态改为ACQUIRED，将待执行的定时任务插入到fired_triggers表。
4. 等待最近的一个定时任务时间间隔（Thread.sleep）后，将定时任务置为触发状态，并触发JobRunShell（JobRunShell.java）执行定时任务。
5. 执行完毕后，将定时任务置为完成，从fired_triggers中删除。

## 我们的优化
1. 采取了druid数据源替代默认的DHCP数据源
2. 记录定时任务的开始结束时间
3. 支持动态参数配置执行

## 核心代码解析


``` java QuartzScheduler.java
// 初始化线程调度器
public QuartzScheduler(QuartzSchedulerResources resources, long idleWaitTime, @Deprecated long dbRetryInterval)
    throws SchedulerException {
    this.resources = resources;
    if (resources.getJobStore() instanceof JobListener) {
        addInternalJobListener((JobListener)resources.getJobStore());
    }
     
    // 启动线程执行调度核心内容
    this.schedThread = new QuartzSchedulerThread(this, resources);
    ThreadExecutor schedThreadExecutor = resources.getThreadExecutor();
    schedThreadExecutor.execute(this.schedThread);
    if (idleWaitTime > 0) {
        this.schedThread.setIdleWaitTime(idleWaitTime);
    }
 
    jobMgr = new ExecutingJobsManager();
    addInternalJobListener(jobMgr);
    errLogger = new ErrorLogger();
    addInternalSchedulerListener(errLogger);
 
    signaler = new SchedulerSignalerImpl(this, this.schedThread);
 
    if(shouldRunUpdateCheck())
        updateTimer = scheduleUpdateCheck();
    else
        updateTimer = null;
 
    getLog().info("Quartz Scheduler v." + getVersion() + " created.");
}
 
// 启动线程调度器进行检查，未完成定时任务扫描等
public void start() throws SchedulerException {
 
    if (shuttingDown|| closed) {
        throw new SchedulerException(
                "The Scheduler cannot be restarted after shutdown() has been called.");
    }
 
    // QTZ-212 : calling new schedulerStarting() method on the listeners
    // right after entering start()
    notifySchedulerListenersStarting();
 
    // 启动定时任务
    if (initialStart == null) {
        initialStart = new Date();
        this.resources.getJobStore().schedulerStarted();
        startPlugins();
    } else {
        resources.getJobStore().schedulerResumed();
    }
 
    schedThread.togglePause(false);
 
    getLog().info(
            "Scheduler " + resources.getUniqueIdentifier() + " started.");
 
    notifySchedulerListenersStarted();
}
```

``` java JobStoreSupport.java

// 调度任务启动方法
public void schedulerStarted() throws SchedulerException {
     
    // 集群模式，启动集群扫描
    if (isClustered()) {
        clusterManagementThread = new ClusterManager();
        if(initializersLoader != null)
            clusterManagementThread.setContextClassLoader(initializersLoader);
        clusterManagementThread.initialize();
    } else {
        try {
            recoverJobs();
        } catch (SchedulerException se) {
            throw new SchedulerConfigException(
                    "Failure occured during job recovery.", se);
        }
    }
 
    // 未完成，错过定时任务扫描
    misfireHandler = new MisfireHandler();
    if(initializersLoader != null)
        misfireHandler.setContextClassLoader(initializersLoader);
    misfireHandler.initialize();
    schedulerRunning = true;
 
    getLog().debug("JobStore background threads started (as scheduler was started).");
}
 
// 获取即将执行的定时任务
protected List<OperableTrigger> acquireNextTrigger(Connection conn, long noLaterThan, int maxCount, long timeWindow)
    throws JobPersistenceException {
    if (timeWindow < 0) {
      throw new IllegalArgumentException();
    }
 
    List<OperableTrigger> acquiredTriggers = new ArrayList<OperableTrigger>();
    Set<JobKey> acquiredJobKeysForNoConcurrentExec = new HashSet<JobKey>();
    final int MAX_DO_LOOP_RETRY = 3;
    int currentLoopCount = 0;
    long firstAcquiredTriggerFireTime = 0;
 
    do {
        currentLoopCount ++;
        try {
            // SQL执行查询
            List<TriggerKey> keys = getDelegate().selectTriggerToAcquire(conn, noLaterThan + timeWindow, getMisfireTime(), maxCount);
 
            // 没有抓取到，直接返回
            if (keys == null || keys.size() == 0)
                return acquiredTriggers;
 
            for(TriggerKey triggerKey: keys) {
 
                // 查看业务系统是否存在相对应的trigger，不存在，不处理
                String jobClass = getDelegate().selectJobClassForTrigger(conn, triggerKey.getName(), triggerKey.getGroup());
                try {
                    getClassLoadHelper().loadClass(jobClass);
                } catch (ClassNotFoundException e) {
                    continue;
                }
 
                // 抓取单个trigger，查看是否存在
                OperableTrigger nextTrigger = retrieveTrigger(conn, triggerKey);
                if(nextTrigger == null) {
                    continue; // next trigger
                }
 
                // If trigger's job is set as @DisallowConcurrentExecution, and it has already been added to result, then
                // put it back into the timeTriggers set and continue to search for next trigger.
                JobKey jobKey = nextTrigger.getJobKey();
                JobDetail job = getDelegate().selectJobDetail(conn, jobKey, getClassLoadHelper());
                if (job.isConcurrentExectionDisallowed()) {
                    if (acquiredJobKeysForNoConcurrentExec.contains(jobKey)) {
                        continue; // next trigger
                    } else {
                        acquiredJobKeysForNoConcurrentExec.add(jobKey);
                    }
                }
 
                // 更新trigger状态为ACQUIRED
                int rowsUpdated = getDelegate().updateTriggerStateFromOtherState(conn, triggerKey, STATE_ACQUIRED, STATE_WAITING);
                if (rowsUpdated <= 0) {
                    continue; // next trigger
                }
 
                // 插入到fired_triggers表
                nextTrigger.setFireInstanceId(getFiredTriggerRecordId());
                getDelegate().insertFiredTrigger(conn, nextTrigger, STATE_ACQUIRED, null);
 
                acquiredTriggers.add(nextTrigger);
                if(firstAcquiredTriggerFireTime == 0)
                    firstAcquiredTriggerFireTime = nextTrigger.getNextFireTime().getTime();
            }
 
            // 如果没有任何即将执行的信息，再次重试三次
            if(acquiredTriggers.size() == 0 && currentLoopCount < MAX_DO_LOOP_RETRY) {
                continue;
            }
 
            // We are done with the while loop.
            break;
        } catch (Exception e) {
            throw new JobPersistenceException(
                      "Couldn't acquire next trigger: " + e.getMessage(), e);
        }
    } while (true);
 
    // Return the acquired trigger list
    return acquiredTriggers;
}
 
// 将定时任务改为触发状态
protected TriggerFiredBundle triggerFired(Connection conn,
        OperableTrigger trigger)
    throws JobPersistenceException {
    JobDetail job;
    Calendar cal = null;
 
    // 查看当前trigger状态，如果不是STATE_ACQUIRED，结束
    try { // if trigger was deleted, state will be STATE_DELETED
        String state = getDelegate().selectTriggerState(conn,
                trigger.getKey());
        if (!state.equals(STATE_ACQUIRED)) {
            return null;
        }
    } catch (SQLException e) {
        throw new JobPersistenceException("Couldn't select trigger state: "
                + e.getMessage(), e);
    }
 
    try {
        job = retrieveJob(conn, trigger.getJobKey());
        if (job == null) { return null; }
    } catch (JobPersistenceException jpe) {
        try {
            getLog().error("Error retrieving job, setting trigger state to ERROR.", jpe);
            getDelegate().updateTriggerState(conn, trigger.getKey(),
                    STATE_ERROR);
        } catch (SQLException sqle) {
            getLog().error("Unable to set trigger state to ERROR.", sqle);
        }
        throw jpe;
    }
 
    if (trigger.getCalendarName() != null) {
        cal = retrieveCalendar(conn, trigger.getCalendarName());
        if (cal == null) { return null; }
    }
 
    try {
        // 将fired_triggers中状态改为EXECUTING
        getDelegate().updateFiredTrigger(conn, trigger, STATE_EXECUTING, job);
    } catch (SQLException e) {
        throw new JobPersistenceException("Couldn't insert fired trigger: "
                + e.getMessage(), e);
    }
 
    Date prevFireTime = trigger.getPreviousFireTime();
 
    // call triggered - to update the trigger's next-fire-time state...
    trigger.triggered(cal);
 
    String state = STATE_WAITING;
    boolean force = true;
 
    if (job.isConcurrentExectionDisallowed()) {
        state = STATE_BLOCKED;
        force = false;
        try {
            // 更新triggers表状态为BLOCKED
            getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),
                    STATE_BLOCKED, STATE_WAITING);
            getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),
                    STATE_BLOCKED, STATE_ACQUIRED);
            getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getKey(),
                    STATE_PAUSED_BLOCKED, STATE_PAUSED);
        } catch (SQLException e) {
            throw new JobPersistenceException(
                    "Couldn't update states of blocked triggers: "
                            + e.getMessage(), e);
        }
    }
 
    if (trigger.getNextFireTime() == null) {
        state = STATE_COMPLETE;
        force = true;
    }
     
    // 更新调度时间后，重新保存定时任务
    storeTrigger(conn, trigger, job, true, state, force, false);
 
    job.getJobDataMap().clearDirtyFlag();
 
    return new TriggerFiredBundle(job, trigger, cal, trigger.getKey().getGroup()
            .equals(Scheduler.DEFAULT_RECOVERY_GROUP), new Date(), trigger
            .getPreviousFireTime(), prevFireTime, trigger.getNextFireTime());
}
 
// 完成定时任务
protected void triggeredJobComplete(Connection conn,
                                    OperableTrigger trigger, JobDetail jobDetail,
                                    CompletedExecutionInstruction triggerInstCode) throws JobPersistenceException {
    try {
        if (triggerInstCode == CompletedExecutionInstruction.DELETE_TRIGGER) {
            if(trigger.getNextFireTime() == null) {
                // double check for possible reschedule within job
                // execution, which would cancel the need to delete...
                TriggerStatus stat = getDelegate().selectTriggerStatus(
                        conn, trigger.getKey());
                if(stat != null && stat.getNextFireTime() == null) {
                    removeTrigger(conn, trigger.getKey());
                }
            } else{
                removeTrigger(conn, trigger.getKey());
                signalSchedulingChangeOnTxCompletion(0L);
            }
        } else if (triggerInstCode == CompletedExecutionInstruction.SET_TRIGGER_COMPLETE) {
            getDelegate().updateTriggerState(conn, trigger.getKey(),
                    STATE_COMPLETE);
            signalSchedulingChangeOnTxCompletion(0L);
        } else if (triggerInstCode == CompletedExecutionInstruction.SET_TRIGGER_ERROR) {
            getLog().info("Trigger " + trigger.getKey() + " set to ERROR state.");
            getDelegate().updateTriggerState(conn, trigger.getKey(),
                    STATE_ERROR);
            signalSchedulingChangeOnTxCompletion(0L);
        } else if (triggerInstCode == CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_COMPLETE) {
            getDelegate().updateTriggerStatesForJob(conn,
                    trigger.getJobKey(), STATE_COMPLETE);
            signalSchedulingChangeOnTxCompletion(0L);
        } else if (triggerInstCode == CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR) {
            getLog().info("All triggers of Job " +
                    trigger.getKey() + " set to ERROR state.");
            getDelegate().updateTriggerStatesForJob(conn,
                    trigger.getJobKey(), STATE_ERROR);
            signalSchedulingChangeOnTxCompletion(0L);
        }
 
        if (jobDetail.isConcurrentExectionDisallowed()) {
            // 更新定时任务到WAITING状态
            getDelegate().updateTriggerStatesForJobFromOtherState(conn,
                    jobDetail.getKey(), STATE_WAITING,
                    STATE_BLOCKED);
 
            getDelegate().updateTriggerStatesForJobFromOtherState(conn,
                    jobDetail.getKey(), STATE_PAUSED,
                    STATE_PAUSED_BLOCKED);
 
            signalSchedulingChangeOnTxCompletion(0L);
        }
        if (jobDetail.isPersistJobDataAfterExecution()) {
            try {
                if (jobDetail.getJobDataMap().isDirty()) {
                    getDelegate().updateJobData(conn, jobDetail);
                }
            } catch (IOException e) {
                throw new JobPersistenceException(
                        "Couldn't serialize job data: " + e.getMessage(), e);
            } catch (SQLException e) {
                throw new JobPersistenceException(
                        "Couldn't update job data: " + e.getMessage(), e);
            }
        }
    } catch (SQLException e) {
        throw new JobPersistenceException(
                "Couldn't update trigger state(s): " + e.getMessage(), e);
    }
 
    try {
        // 删除fired_triggers数据
        getDelegate().deleteFiredTrigger(conn, trigger.getFireInstanceId());
    } catch (SQLException e) {
        throw new JobPersistenceException("Couldn't delete fired trigger: "
                + e.getMessage(), e);
    }
}
 
// 锁实现，事务实现
protected <T> T executeInNonManagedTXLock(
        String lockName,
        TransactionCallback<T> txCallback, final TransactionValidator<T> txValidator) throws JobPersistenceException {
    boolean transOwner = false;
    Connection conn = null;
    try {
        if (lockName != null) {
            // If we aren't using db locks, then delay getting DB connection
            // until after acquiring the lock since it isn't needed.
            if (getLockHandler().requiresConnection()) {
                conn = getNonManagedTXConnection();
            }
             
            transOwner = getLockHandler().obtainLock(conn, lockName);
        }
         
        if (conn == null) {
            conn = getNonManagedTXConnection();
        }
         
        final T result = txCallback.execute(conn);
        try {
            commitConnection(conn);
        } catch (JobPersistenceException e) {
            rollbackConnection(conn);
            if (txValidator == null || !retryExecuteInNonManagedTXLock(lockName, new TransactionCallback<Boolean>() {
                @Override
                public Boolean execute(Connection conn) throws JobPersistenceException {
                    return txValidator.validate(conn, result);
                }
            })) {
                throw e;
            }
        }
 
        Long sigTime = clearAndGetSignalSchedulingChangeOnTxCompletion();
        if(sigTime != null && sigTime >= 0) {
            signalSchedulingChangeImmediately(sigTime);
        }
         
        return result;
    } catch (JobPersistenceException e) {
        rollbackConnection(conn);
        throw e;
    } catch (RuntimeException e) {
        rollbackConnection(conn);
        throw new JobPersistenceException("Unexpected runtime exception: "
                + e.getMessage(), e);
    } finally {
        try {
            releaseLock(lockName, transOwner);
        } finally {
            cleanupConnection(conn);
        }
    }
}
```
``` java DBSemaphore.java

private void setExpandedSQL() {
    if (getTablePrefix() != null && getSchedName() != null && sql != null && insertSql != null) {
        expandedSQL = Util.rtp(this.sql, getTablePrefix(), getSchedulerNameLiteral());
        expandedInsertSQL = Util.rtp(this.insertSql, getTablePrefix(), getSchedulerNameLiteral());
    }
}
 
// 获取锁
public boolean obtainLock(Connection conn, String lockName)
    throws LockException {
 
    if(log.isDebugEnabled()) {
        log.debug(
            "Lock '" + lockName + "' is desired by: "
                    + Thread.currentThread().getName());
    }
    if (!isLockOwner(lockName)) {
         
        // 执行获取锁的方式
        executeSQL(conn, lockName, expandedSQL, expandedInsertSQL);
         
        if(log.isDebugEnabled()) {
            log.debug(
                "Lock '" + lockName + "' given to: "
                        + Thread.currentThread().getName());
        }
        getThreadLocks().add(lockName);
        //getThreadLocksObtainer().put(lockName, new
        // Exception("Obtainer..."));
    } else if(log.isDebugEnabled()) {
        log.debug(
            "Lock '" + lockName + "' Is already owned by: "
                    + Thread.currentThread().getName());
    }
 
    return true;
}
```

``` java StdRowLockSemaphore.java

public static final String SELECT_FOR_LOCK = "SELECT * FROM "
        + TABLE_PREFIX_SUBST + TABLE_LOCKS + " WHERE " + COL_SCHEDULER_NAME + " = " + SCHED_NAME_SUBST
        + " AND " + COL_LOCK_NAME + " = ? FOR UPDATE";
 
public static final String INSERT_LOCK = "INSERT INTO "
    + TABLE_PREFIX_SUBST + TABLE_LOCKS + "(" + COL_SCHEDULER_NAME + ", " + COL_LOCK_NAME + ") VALUES ("
    + SCHED_NAME_SUBST + ", ?)";
 
@Override
protected void executeSQL(Connection conn, final String lockName, final String expandedSQL, final String expandedInsertSQL) throws LockException {
    PreparedStatement ps = null;
    ResultSet rs = null;
    SQLException initCause = null;
     
    // attempt lock two times (to work-around possible race conditions in inserting the lock row the first time running)
    int count = 0;
    do {
        count++;
        try {
            // 执行for update语句
            ps = conn.prepareStatement(expandedSQL);
            ps.setString(1, lockName);
             
            if (getLog().isDebugEnabled()) {
                getLog().debug(
                    "Lock '" + lockName + "' is being obtained: " +
                    Thread.currentThread().getName());
            }
            rs = ps.executeQuery();
 
            // 影响找不到
            if (!rs.next()) {
                getLog().debug(
                        "Inserting new lock row for lock: '" + lockName + "' being obtained by thread: " +
                        Thread.currentThread().getName());
                rs.close();
                rs = null;
                ps.close();
                ps = null;
                // 插入锁
                ps = conn.prepareStatement(expandedInsertSQL);
                ps.setString(1, lockName);
 
                int res = ps.executeUpdate();
                 
                if(res != 1) {
                    if(count < 3) {
                        // pause a bit to give another thread some time to commit the insert of the new lock row
                        try {
                            Thread.sleep(1000L);
                        } catch (InterruptedException ignore) {
                            Thread.currentThread().interrupt();
                        }
                        // try again ...
                        continue;
                    }
                 
                    throw new SQLException(Util.rtp(
                        "No row exists, and one could not be inserted in table " + TABLE_PREFIX_SUBST + TABLE_LOCKS +
                        " for lock named: " + lockName, getTablePrefix(), getSchedulerNameLiteral()));
                }
            }
             
            // 加锁成功，直接返回
            return; // obtained lock, go
        } catch (SQLException sqle) {
 
            if(initCause == null)
                initCause = sqle;
             
            if (getLog().isDebugEnabled()) {
                getLog().debug(
                    "Lock '" + lockName + "' was not obtained by: " +
                    Thread.currentThread().getName() + (count < 3 ? " - will try again." : ""));
            }
             
            if(count < 3) {
                // pause a bit to give another thread some time to commit the insert of the new lock row
                try {
                    Thread.sleep(1000L);
                } catch (InterruptedException ignore) {
                    Thread.currentThread().interrupt();
                }
                // try again ...
                continue;
            }
             
            throw new LockException("Failure obtaining db row lock: "
                    + sqle.getMessage(), sqle);
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception ignore) {
                }
            }
            if (ps != null) {
                try {
                    ps.close();
                } catch (Exception ignore) {
                }
            }
        }
    } while(count < 4);
 
    // 循环4次加锁
     
    throw new LockException("Failure obtaining db row lock, reached maximum number of attempts. Initial exception (if any) attached as root cause.", initCause);
}
```

``` java QuartzSchedulerThead.java

public void run() {
    boolean lastAcquireFailed = false;
     
    // 无限循环调用
    while (!halted.get()) {
        try {
            // check if we're supposed to pause...
            synchronized (sigLock) {
                while (paused && !halted.get()) {
                    try {
                        // wait until togglePause(false) is called...
                        sigLock.wait(1000L);
                    } catch (InterruptedException ignore) {
                    }
                }
 
                if (halted.get()) {
                    break;
                }
            }
             
            // 当前可用的线程数量
            int availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();
            if(availThreadCount > 0) { // will always be true, due to semantics of blockForAvailableThreads...
 
                List<OperableTrigger> triggers = null;
 
                long now = System.currentTimeMillis();
 
                clearSignaledSchedulingChange();
                try {
                    // 获取即将执行的定时任务
                    triggers = qsRsrcs.getJobStore().acquireNextTriggers(
                            now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());
                    lastAcquireFailed = false;
                    if (log.isDebugEnabled())
                        log.debug("batch acquisition of " + (triggers == null ? 0 : triggers.size()) + " triggers");
                } catch (JobPersistenceException jpe) {
                    if(!lastAcquireFailed) {
                        qs.notifySchedulerListenersError(
                            "An error occurred while scanning for the next triggers to fire.",
                            jpe);
                    }
                    lastAcquireFailed = true;
                    continue;
                } catch (RuntimeException e) {
                    if(!lastAcquireFailed) {
                        getLog().error("quartzSchedulerThreadLoop: RuntimeException "
                                +e.getMessage(), e);
                    }
                    lastAcquireFailed = true;
                    continue;
                }
                 
                // 是否需要放弃此次定时任务
                if (triggers != null && !triggers.isEmpty()) {
 
                    now = System.currentTimeMillis();
                    long triggerTime = triggers.get(0).getNextFireTime().getTime();
                    long timeUntilTrigger = triggerTime - now;
                    while(timeUntilTrigger > 2) {
                        synchronized (sigLock) {
                            if (halted.get()) {
                                break;
                            }
                            if (!isCandidateNewTimeEarlierWithinReason(triggerTime, false)) {
                                try {
                                    // we could have blocked a long while
                                    // on 'synchronize', so we must recompute
                                    now = System.currentTimeMillis();
                                    timeUntilTrigger = triggerTime - now;
                                    if(timeUntilTrigger >= 1)
                                        sigLock.wait(timeUntilTrigger);
                                } catch (InterruptedException ignore) {
                                }
                            }
                        }
                        if(releaseIfScheduleChangedSignificantly(triggers, triggerTime)) {
                            break;
                        }
                        now = System.currentTimeMillis();
                        timeUntilTrigger = triggerTime - now;
                    }
 
                    // this happens if releaseIfScheduleChangedSignificantly decided to release triggers
                    if(triggers.isEmpty())
                        continue;
 
                    // set triggers to 'executing'
                    List<TriggerFiredResult> bndles = new ArrayList<TriggerFiredResult>();
 
                    boolean goAhead = true;
                    synchronized(sigLock) {
                        goAhead = !halted.get();
                    }
                    if(goAhead) {
                        try {
                            // 将数据库状体改为正在执行
                            List<TriggerFiredResult> res = qsRsrcs.getJobStore().triggersFired(triggers);
                            if(res != null)
                                bndles = res;
                        } catch (SchedulerException se) {
                            qs.notifySchedulerListenersError(
                                    "An error occurred while firing triggers '"
                                            + triggers + "'", se);
                            //QTZ-179 : a problem occurred interacting with the triggers from the db
                            //we release them and loop again
                            for (int i = 0; i < triggers.size(); i++) {
                                qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));
                            }
                            continue;
                        }
 
                    }
 
                    for (int i = 0; i < bndles.size(); i++) {
                        TriggerFiredResult result =  bndles.get(i);
                        TriggerFiredBundle bndle =  result.getTriggerFiredBundle();
                        Exception exception = result.getException();
 
                        if (exception instanceof RuntimeException) {
                            getLog().error("RuntimeException while firing trigger " + triggers.get(i), exception);
                            qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));
                            continue;
                        }
 
                        // it's possible to get 'null' if the triggers was paused,
                        // blocked, or other similar occurrences that prevent it being
                        // fired at this time...  or if the scheduler was shutdown (halted)
                        if (bndle == null) {
                            qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));
                            continue;
                        }
 
                        JobRunShell shell = null;
                        try {
                            // 创建定时任务的执行脚本
                            shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);
                            shell.initialize(qs);
                        } catch (SchedulerException se) {
                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);
                            continue;
                        }
                     
                        // 将当前的JobRunShell加入线程池，基本上永远成功
                        if (qsRsrcs.getThreadPool().runInThread(shell) == false) {
                            // this case should never happen, as it is indicative of the
                            // scheduler being shutdown or a bug in the thread pool or
                            // a thread pool being used concurrently - which the docs
                            // say not to do...
                            getLog().error("ThreadPool.runInThread() return false!");
                             
                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);
                        }
 
                    }
                    // 循环执行
                    continue; // while (!halted)
                }
            } else { // if(availThreadCount > 0)
                // should never happen, if threadPool.blockForAvailableThreads() follows contract
                continue; // while (!halted)
            }
 
            long now = System.currentTimeMillis();
            long waitTime = now + getRandomizedIdleWaitTime();
            long timeUntilContinue = waitTime - now;
            synchronized(sigLock) {
                try {
                  if(!halted.get()) {
                    // QTZ-336 A job might have been completed in the mean time and we might have
                    // missed the scheduled changed signal by not waiting for the notify() yet
                    // Check that before waiting for too long in case this very job needs to be
                    // scheduled very soon
                    if (!isScheduleChanged()) {
                      sigLock.wait(timeUntilContinue);
                    }
                  }
                } catch (InterruptedException ignore) {
                }
            }
 
        } catch(RuntimeException re) {
            getLog().error("Runtime error occurred in main trigger firing loop.", re);
        }
    } // while (!halted)
 
    // drop references to scheduler stuff to aid garbage collection...
    qs = null;
    qsRsrcs = null;
}
```
``` java JobRunShell.java

public void run() {
    qs.addInternalSchedulerListener(this);
 
    try {
        OperableTrigger trigger = (OperableTrigger) jec.getTrigger();
        JobDetail jobDetail = jec.getJobDetail();
 
        do {
 
            JobExecutionException jobExEx = null;
            Job job = jec.getJobInstance();
 
            try {
                begin();
            } catch (SchedulerException se) {
                qs.notifySchedulerListenersError("Error executing Job ("
                        + jec.getJobDetail().getKey()
                        + ": couldn't begin execution.", se);
                break;
            }
 
            // notify job & trigger listeners...
            try {
                if (!notifyListenersBeginning(jec)) {
                    break;
                }
            } catch(VetoedException ve) {
                try {
                    CompletedExecutionInstruction instCode = trigger.executionComplete(jec, null);
                    qs.notifyJobStoreJobVetoed(trigger, jobDetail, instCode);
                     
                    // QTZ-205
                    // Even if trigger got vetoed, we still needs to check to see if it's the trigger's finalized run or not.
                    if (jec.getTrigger().getNextFireTime() == null) {
                        qs.notifySchedulerListenersFinalized(jec.getTrigger());
                    }
 
                    complete(true);
                } catch (SchedulerException se) {
                    qs.notifySchedulerListenersError("Error during veto of Job ("
                            + jec.getJobDetail().getKey()
                            + ": couldn't finalize execution.", se);
                }
                break;
            }
            // 记录开始结束时间
            long startTime = System.currentTimeMillis();
            long endTime = startTime;
 
            // execute the job
            try {
                log.debug("Calling execute on job " + jobDetail.getKey());
                // 调用定时任务具体方法
                job.execute(jec);
                endTime = System.currentTimeMillis();
            } catch (JobExecutionException jee) {
                endTime = System.currentTimeMillis();
                jobExEx = jee;
                getLog().info("Job " + jobDetail.getKey() +
                        " threw a JobExecutionException: ", jobExEx);
            } catch (Throwable e) {
                endTime = System.currentTimeMillis();
                getLog().error("Job " + jobDetail.getKey() +
                        " threw an unhandled Exception: ", e);
                SchedulerException se = new SchedulerException(
                        "Job threw an unhandled exception.", e);
                qs.notifySchedulerListenersError("Job ("
                        + jec.getJobDetail().getKey()
                        + " threw an exception.", se);
                jobExEx = new JobExecutionException(se, false);
            }
            log.info("start record job log");
            //execute log
            try {
                String currentIp = InetAddress.getLocalHost().getHostAddress();
                // 记录定时任务执行记录
                qs.recordJobLog(jec.getTrigger(),startTime,endTime, currentIp);
                log.info("end record job log");
            } catch (UnknownHostException e) {
                log.warn("record execute log error");
            } catch (SchedulerException e) {
                log.warn("record execute log error");
            }
 
            jec.setJobRunTime(endTime - startTime);
 
            // notify all job listeners
            if (!notifyJobListenersComplete(jec, jobExEx)) {
                break;
            }
 
            CompletedExecutionInstruction instCode = CompletedExecutionInstruction.NOOP;
 
            // update the trigger
            try {
                instCode = trigger.executionComplete(jec, jobExEx);
            } catch (Exception e) {
                // If this happens, there's a bug in the trigger...
                SchedulerException se = new SchedulerException(
                        "Trigger threw an unhandled exception.", e);
                qs.notifySchedulerListenersError(
                        "Please report this error to the Quartz developers.",
                        se);
            }
 
            // notify all trigger listeners
            if (!notifyTriggerListenersComplete(jec, instCode)) {
                break;
            }
 
            // update job/trigger or re-execute job
            if (instCode == CompletedExecutionInstruction.RE_EXECUTE_JOB) {
                jec.incrementRefireCount();
                try {
                    complete(false);
                } catch (SchedulerException se) {
                    qs.notifySchedulerListenersError("Error executing Job ("
                            + jec.getJobDetail().getKey()
                            + ": couldn't finalize execution.", se);
                }
                continue;
            }
 
            try {
                complete(true);
            } catch (SchedulerException se) {
                qs.notifySchedulerListenersError("Error executing Job ("
                        + jec.getJobDetail().getKey()
                        + ": couldn't finalize execution.", se);
                continue;
            }
 
            // 完成定时任务
            qs.notifyJobStoreJobComplete(trigger, jobDetail, instCode);
            break;
        } while (true);
 
    } finally {
        qs.removeInternalSchedulerListener(this);
    }
}
```